using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Globalization;
using System.Text;
using Microsoft.EntityFrameworkCore;
// ReSharper disable EntityFramework.ModelValidation.UnlimitedStringLength

namespace Wellcome.Dds.Common;

[Index(nameof(PackageIdentifier), IsUnique = false)]
[Index(nameof(PathElementSafe), IsUnique = true)]
public class DdsIdentity
{
    public required string Value { get; init; }

    [Key]
    public required string LowerCaseValue { get; set; }
    
    /// <summary>
    /// The identifier for the stored digital object of which this ID might be whole or part.
    /// This is needed to obtain the object from the storage service, or look up a record in the Catalogue API.
    /// 
    /// The majority of DdsIdentifiers are the same string as their packageIdentifiers - e.g.,
    /// b12312312 or PPCRI/A/B/C
    /// But for multiple manifestations, different identifiers belong to the same package:
    /// b19974760_10 and b19974760_10_10 have the same PackageIdentifier, b19974760.
    /// </summary>
    public required string PackageIdentifier { get; init; }
        
    /// <summary>
    /// A version of the PackageIdentifier that would only be one path element in a URL or file name
    /// </summary>
    public required string PackageIdentifierPathElementSafe { get; init; }
        
    /// <summary>
    /// Sometimes a caller doesn't know whether the identfier is a package identifier or a sub part,
    /// but wants a path-safe form anyway.
    /// </summary>
    public required string PathElementSafe { get; init; }
        
    /// <summary>
    /// What prefix in the storage service API is required to locate this object's files
    /// Currently either "digitised" or "born-digital", or
    /// may be null if the identifier does not correspond to a digital object.
    /// </summary>
    public string? StorageSpace { get; set; }
    
    /// <summary>
    /// Which software / workflow produced the digital object, its METS, etc.
    /// May be null if the identifier does not correspond to a digital object (was not generated by a workflow tool)
    /// </summary>
    public string? Generator { get; set; }
    
    /// <summary>
    /// What system of record (LMS / CMS / CatalogueAPI) issued the identifier?
    /// </summary>
    public required string Source { get; set; }
    
    /// <summary>
    /// The work identifier (usually) in the Catalogue API corresponding to this item
    /// </summary>
    public string? CatalogueId { get; set; }

    public Dictionary<string, string> AllIdentities = new();

    // How do we retain the notion of volume and issue... keep as is? We have lots of MMs.
    
    public string? VolumePart { get; set; }
    public string? IssuePart { get; set; }
    
    public bool IsPackageLevelIdentifier { get; set; }
    
    public required string Level { get; set; }
    
    public DateTime Created { get; init; }
    
    public DateTime Updated { get; set; }
    
    /// <summary>
    /// Whether the Identity information was deduced from explicit knowledge of the generator, or was simply parsed.
    ///
    /// If true, the record creation or update was instigated by the system that makes the METS file - the generator.
    /// (you could force a reset by setting this to false)
    /// </summary>
    public bool FromGenerator { get; set; }

    /// <summary>
    /// Has the storage space been checked by attempting to load a Storage Manifest from it for this identifier?
    /// (Package level only)
    /// </summary>
    public bool StorageSpaceValidated { get; set; }

    /// <summary>
    /// Has the Catalogue source been validated?
    /// (Always false for now)
    /// </summary>
    public bool SourceValidated { get; set; }

    public static bool operator ==(DdsIdentity? d1, DdsIdentity? d2)
    {
        if (d1 is null)
        {
            return d2 is null;
        }

        if (ReferenceEquals(d1, d2))
        {
            return true;
        }

        return d2 != null && d1.Value == d2.Value;
    }

    public static bool operator !=(DdsIdentity? d1, DdsIdentity? d2)
    {
        return !(d1 == d2);
    }

    public override bool Equals(object? obj)
    {
        return obj is DdsIdentity identifier && this == identifier;
    }
    
    public override int GetHashCode()
    {
        return Value.GetHashCode();
    }
    
    public override string ToString() => Value;

    public string GetVerbose()
    {
        var sb = new StringBuilder();
        sb.Append("Identity: ");
        sb.AppendLine(Value);
        sb.Append("Generator: ");
        sb.AppendLine(Generator);
        sb.Append("FromGenerator: ");
        sb.AppendLine(FromGenerator.ToString());
        sb.Append("PackageIdentifier: ");
        sb.AppendLine(PackageIdentifier);
        sb.Append("PackageIdentifierPathElementSafe: ");
        sb.AppendLine(PackageIdentifierPathElementSafe);
        sb.Append("PathElementSafe: ");
        sb.AppendLine(PathElementSafe);
        sb.Append("StorageSpace: ");
        sb.AppendLine(StorageSpace);
        sb.Append("StorageSpaceValidated: ");
        sb.AppendLine(StorageSpaceValidated.ToString());
        sb.Append("Source: ");
        sb.AppendLine(Source);
        sb.Append("SourceValidated: ");
        sb.AppendLine(SourceValidated.ToString());
        sb.Append("Created: ");
        sb.AppendLine(Created.ToString(CultureInfo.InvariantCulture));
        sb.Append("Updated: ");
        sb.AppendLine(Updated.ToString(CultureInfo.InvariantCulture));
        return sb.ToString();
    }
}


public static class StorageSpace
{
    public const string Digitised = "digitised";
    public const string BornDigital = "born-digital";
    
    public static bool IsKnown(string? storageSpace)
    {
        return storageSpace is Digitised or BornDigital;
    }

    public static List<string> All => [Digitised, BornDigital];
}

public static class Generator
{
    public const string Goobi = "goobi";
    public const string Archivematica = "archivematica";
    public const string Dashboard = "dashboard";

    public static bool IsKnown(string generator)
    {
        return generator is Goobi or Archivematica;
    }
    
    public static bool IsIgnored(string generator)
    {
        return generator is Dashboard;
    }
}

public static class Source
{
    public const string Sierra = "sierra"; // b numbers
    public const string Calm = "calm";
    
    public static bool IsKnown(string source)
    {
        return source is Sierra or Calm;
    }
}

public static class IdentifierLevel
{
    public const string Package = "package";
    public const string Volume = "volume";
    public const string Issue = "issue";
}