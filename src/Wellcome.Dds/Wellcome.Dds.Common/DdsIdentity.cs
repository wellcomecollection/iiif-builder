using System.Collections.Generic;

namespace Wellcome.Dds.Common;

public class DdsIdentity
{
    /// <summary>
    /// The identifier for the stored digital object of which this ID might be whole or part.
    /// This is needed to obtain the object from the storage service, or look up a record in the Catalogue API.
    /// 
    /// The majority of DdsIdentifiers are the same string as their packageIdentifiers - e.g.,
    /// b12312312 or PPCRI/A/B/C
    /// But for multiple manifestations, different identifiers belong to the same package:
    /// b19974760_10 and b19974760_10_10 have the same PackageIdentifier, b19974760.
    /// </summary>
    public required string PackageIdentifier { get; set; }
        
    /// <summary>
    /// A version of the PackageIdentifier that would only be one path element in a URL or file name
    /// </summary>
    public required string PackageIdentifierPathElementSafe { get; set; }
        
    /// <summary>
    /// Sometimes a caller doesn't know whether the identfier is a package identifier or a sub part,
    /// but wants a path-safe form anyway.
    /// </summary>
    public required string PathElementSafe { get; set; }
        
    /// <summary>
    /// What prefix in the storage service API is required to locate this object's files
    /// Currently either "digitised" or "born-digital", or
    /// may be null if the identifier does not correspond to a digital object.
    /// </summary>
    public string? StorageSpace { get; set; }
    
    /// <summary>
    /// Which software / workflow produced the digital object, its METS, etc.
    /// May be null if the identifier does not correspond to a digital object (was not generated by a workflow tool)
    /// </summary>
    public string? Generator { get; set; }
    
    /// <summary>
    /// What system of record (LMS / CMS / CatalogueAPI) issued the identifier?
    /// </summary>
    public required string Source { get; set; }
    
    /// <summary>
    /// The work identifier (usually) in the Catalogue API corresponding to this item
    /// </summary>
    public string? CatalogueId { get; set; }

    public Dictionary<string, string> SourceMap = new();

    // How do we retain the notion of volume and issue... keep as is? We have lots of MMs.
}


public static class StorageSpace
{
    public const string Digitised = "digitised";
    public const string BornDigital = "born-digital";
}

public static class Generator
{
    public const string Goobi = "goobi";
    public const string Archivematica = "archivematica";
}

public static class Source
{
    public const string Sierra = "sierra"; // b numbers
    public const string Calm = "calm";
    public const string CatalogueApi = "catalogueapi";
    // other sources may follow
    
    public static readonly List<string> AllSources = [Sierra, Calm, CatalogueApi];
}